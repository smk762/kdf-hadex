<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KDF Orderbook Widget</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #00d4aa;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            color: #888;
            font-size: 1.1rem;
        }

        .coin-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .coin-btn {
            background: #2a2a2a;
            border: 2px solid #444;
            color: #fff;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .coin-btn:hover {
            background: #3a3a3a;
            border-color: #00d4aa;
        }

        .coin-btn.active {
            background: #00d4aa;
            border-color: #00d4aa;
            color: #000;
        }

        .orderbook-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .orderbook-section {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #444;
        }

        .orderbook-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }

        .orderbook-title {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .orderbook-title.bids {
            color: #00ff88;
        }

        .orderbook-title.asks {
            color: #ff4444;
        }

        .orderbook-table {
            width: 100%;
        }

        .orderbook-table th,
        .orderbook-table td {
            padding: 8px 12px;
            text-align: right;
            font-size: 14px;
        }

        .orderbook-table th {
            background: #333;
            color: #aaa;
            font-weight: 500;
            border-bottom: 1px solid #444;
        }

        .orderbook-table td {
            border-bottom: 1px solid #333;
        }

        .orderbook-table tr:hover {
            background: #333;
        }

        .price {
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .price.bid {
            color: #00ff88;
        }

        .price.ask {
            color: #ff4444;
        }

        .volume {
            color: #aaa;
            font-family: 'Courier New', monospace;
        }

        .spread {
            text-align: center;
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .spread-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: #00d4aa;
            font-family: 'Courier New', monospace;
        }

        .spread-label {
            color: #aaa;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .loading {
            text-align: center;
            color: #888;
            padding: 40px;
        }

        .error {
            text-align: center;
            color: #ff4444;
            padding: 40px;
            background: #2a1a1a;
            border-radius: 8px;
            border: 1px solid #ff4444;
        }

        .refresh-btn {
            background: #00d4aa;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s ease;
        }

        .refresh-btn:hover {
            background: #00b894;
        }

        .last-updated {
            text-align: center;
            color: #666;
            font-size: 0.9rem;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .orderbook-container {
                grid-template-columns: 1fr;
            }
            
            .coin-selector {
                justify-content: flex-start;
                overflow-x: auto;
                padding-bottom: 10px;
            }
            
            .coin-btn {
                white-space: nowrap;
                flex-shrink: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 id="page-title">KDF Orderbook</h1>
            <p id="pair-name">Pair: --/--</p>
            <p>Real-time orderbook data from Komodo DeFi Framework</p>
        </div>

        <div class="coin-selector" style="gap:8px;align-items:center;">
            <div>
                <label for="base-select" style="display:block;font-size:0.9rem;color:#aaa;margin-bottom:6px">Base coin</label>
                <select id="base-select" style="padding:8px;border-radius:6px;background:#2a2a2a;color:#fff;border:1px solid #444;min-width:160px"></select>
            </div>
            <div>
                <label for="rel-select" style="display:block;font-size:0.9rem;color:#aaa;margin-bottom:6px">Rel coin</label>
                <select id="rel-select" style="padding:8px;border-radius:6px;background:#2a2a2a;color:#fff;border:1px solid #444;min-width:120px"></select>
            </div>
        </div>

        <div class="spread">
            <div class="spread-value" id="spread">--</div>
            <div class="spread-label">Spread</div>
        </div>

        <div class="orderbook-container">
            <div class="orderbook-section">
                <div class="orderbook-header">
                    <div class="orderbook-title bids">Bids (Buy Orders)</div>
                    <button class="refresh-btn" onclick="refreshOrderbook()">Refresh</button>
                </div>
                <table class="orderbook-table">
                    <thead>
                        <tr>
                            <th>Ticker</th>
                            <th>Price</th>
                            <th>Price (<span id="fiat-unit-asks">AUD</span>)</th>
                            <th>Min Rel Vol</th>
                            <th>Max Rel Vol</th>
                            <th>Min Base Vol</th>
                            <th>Max Base Vol</th>
                        </tr>
                    </thead>
                    <tbody id="bids-table">
                        <tr>
                            <td colspan="7" class="loading">Loading...</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="orderbook-section">
                <div class="orderbook-header">
                    <div class="orderbook-title asks">Asks (Sell Orders)</div>
                </div>
                <table class="orderbook-table">
                    <thead>
                        <tr>
                            <th>Ticker</th>
                            <th>Price</th>
                            <th>Price (<span id="fiat-unit-asks">AUD</span>)</th>
                            <th>Min Rel Vol</th>
                            <th>Max Rel Vol</th>
                            <th>Min Base Vol</th>
                            <th>Max Base Vol</th>
                        </tr>
                    </thead>
                    <tbody id="asks-table">
                        <tr>
                            <td colspan="7" class="loading">Loading...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="last-updated" id="last-updated">
            Last updated: Never
        </div>
    </div>

    <script>
        // Configuration
        const KDF_RPC_URL = 'http://localhost:7783';
        const RPC_PASSWORD = 'CHANGE_ME'; // This should be configured properly
        
        let currentBase = 'USD';
        let currentRel = 'AUD';
        let orderbookData = null;

        // Coin configurations
        // coinConfigs will be populated from coins_config.json via panel-server
        const coinConfigs = {};

        // Initialize the widget
        document.addEventListener('DOMContentLoaded', function() {
            // populate rel select and base buttons from SUPPORTED_COINS if available
            // Fetch coins config from API and populate selectors (async)
            (async function () {
                try {
                    const resp = await fetch('./api/coins_config');
                    if (resp.ok) {
                        const cj = await resp.json();
                        const cfg = cj.coins_config || {};
                        window.COINS_CONFIG = cfg;
                        // populate base and rel selects
                        const baseSel = document.getElementById('base-select');
                        const relSel = document.getElementById('rel-select');
                        if (baseSel) baseSel.innerHTML = '';
                        if (relSel) relSel.innerHTML = '';
                        Object.keys(cfg).forEach(t => {
                            const info = cfg[t] || {};
                            const label = info && info.name ? info.name : t;
                            if (baseSel) {
                                const o = document.createElement('option'); o.value = t; o.textContent = `${t} — ${label}`; baseSel.appendChild(o);
                            }
                            if (relSel) {
                                const o2 = document.createElement('option'); o2.value = t; o2.textContent = label; relSel.appendChild(o2);
                            }
                        });
                    } else {
                        window.COINS_CONFIG = {};
                    }
                } catch (e) {
                    console.error('Failed to fetch coins_config:', e);
                    window.COINS_CONFIG = {};
                }
            })();

            setupCoinSelector();
            // set fiat header immediately from saved options so header shows correct unit
            (async function(){
                try{
                    const optsResp = await fetch('./api/options');
                    if(optsResp.ok){
                        const oj = await optsResp.json();
                        const cur = (oj.options||{}).selected_fiat_currency || null;
                        if(cur){
                            const el = document.getElementById('fiat-unit');
                            const el2 = document.getElementById('fiat-unit-asks');
                            if(el) el.textContent = cur.toUpperCase();
                            if(el2) el2.textContent = cur.toUpperCase();
                        }
                    }
                }catch(e){/*ignore*/}
                // listen for localStorage changes (so coins.html can update header immediately)
                try{
                    window.addEventListener('storage', (ev) => {
                        if(ev.key === 'kdf_selected_fiat'){
                            const cur = ev.newValue;
                            const el = document.getElementById('fiat-unit');
                            const el2 = document.getElementById('fiat-unit-asks');
                            if(el) el.textContent = (cur||'').toUpperCase();
                            if(el2) el2.textContent = (cur||'').toUpperCase();
                        }
                    });
                }catch(e){}
            })();
            // check URL query params for deep-links
            try {
                const params = new URLSearchParams(window.location.search);
                const b = params.get('base');
                const r = params.get('rel');
                currentBase = b || 'DGB';
                currentRel = r || 'KMD';
                // mark active base button
                const baseSel = document.getElementById('base-select');
                if (baseSel) baseSel.value = currentBase;
                const relSel = document.getElementById('rel-select');
                if (relSel) relSel.value = currentRel;
            } catch (e) {
                currentBase = 'DGB';
                currentRel = 'KMD';
            }

            loadOrderbook();
            
            // Auto-refresh every 30 seconds
            setInterval(loadOrderbook, 30000);
        });

        function setupCoinSelector() {
            const coinButtons = document.querySelectorAll('.coin-btn');
            coinButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    // Remove active class from all buttons
                    coinButtons.forEach(b => b.classList.remove('active'));
                    // Add active class to clicked button
                    this.classList.add('active');

                    // Update current base coin
                    currentBase = this.dataset.coin;
                    document.getElementById('pair-name').textContent = `Pair: ${currentBase}/${currentRel}`;

                    // Load new orderbook
                    loadOrderbook();
                });
            });

            // Rel selector change
            const relSel = document.getElementById('rel-select');
            if (relSel) {
                relSel.addEventListener('change', function() {
                    currentRel = this.value;
                    document.getElementById('pair-name').textContent = `Pair: ${currentBase}/${currentRel}`;
                    loadOrderbook();
                });
            }
        }

        async function loadOrderbook() {
            try {
                const cfg = coinConfigs[currentBase] || { base: currentBase };
                const base = cfg.base;
                const rel = currentRel;
                document.getElementById('pair-name').textContent = `Pair: ${base}/${rel}`;

                // Use panel server kdf_request endpoint to fetch orderbook
                try {
                    const res = await fetch('./api/kdf_request', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ method: 'orderbook', params: { base: base, rel: rel } })
                    });
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    const j = await res.json();

                    // Response may be raw, or wrapped as {mmrpc:'2.0', result: {...}}
                    let ob = j && (j.result || j);
                    if (ob && ob.result) ob = ob.result;
                    // also support array wrapper
                    if (Array.isArray(ob) && ob.length) ob = ob[0];

                    if (!ob) {
                        console.error('Orderbook: empty response', j);
                        displayError('Empty orderbook response');
                    } else if (ob.error) {
                        const em = typeof ob.error === 'string' ? ob.error : JSON.stringify(ob.error);
                        displayError(em);
                    } else if (ob.bids && ob.asks) {
                        // gather UI/context data (selected fiat, available fiats, kdf tickers) to compute fiat prices
                        const [optsResp, afResp, cgResp, tkResp] = await Promise.allSettled([
                            fetch('./api/options'),
                            fetch('./api/available_fiats'),
                            fetch('./api/coingecko_prices'),
                            fetch('./api/tickers')
                        ]);
                        let selectedFiat = null;
                        let availableFiats = [];
                        let coingeckoPrices = null;
                        let kdfTickers = null;
                        try{ if(optsResp.status==='fulfilled' && optsResp.value.ok){ const oj = await optsResp.value.json(); selectedFiat = (oj.options||{}).selected_fiat_currency || null } }catch(e){}
                        try{ if(afResp.status==='fulfilled' && afResp.value.ok){ const afj = await afResp.value.json(); availableFiats = afj.available_fiats || []; } }catch(e){}
                        try{ if(cgResp.status==='fulfilled' && cgResp.value.ok){ const cj = await cgResp.value.json(); coingeckoPrices = cj.prices || {}; /* filter to supported coins */ const supported = Object.keys(window.COINS_CONFIG||{}); const filtered = {}; Object.keys(coingeckoPrices).forEach(k=>{ const t = (coingeckoPrices[k] && coingeckoPrices[k].coingecko_id) ? (coingeckoPrices[k].ticker || null) : null; /* try to map by ticker fallback */ }); /* coingecko endpoint already returned mapping by ticker in panel-server; we'll trust returned keys */ } }catch(e){}
                        try{ if(tkResp.status==='fulfilled' && tkResp.value.ok){ const tj = await tkResp.value.json(); kdfTickers = (tj && (tj.result||tj)) || null; } }catch(e){}

                        displayOrderbook({ bids: ob.bids, asks: ob.asks, spread: ob.spread || '0.0', selectedFiat, availableFiats, coingeckoPrices, kdfTickers, base: base, rel: rel });
                    } else if (ob.orders) {
                        // some KDF formats nest under orders -> pair -> { bids, asks }
                        // Try to find first pair entry
                        const firstKey = Object.keys(ob.orders || {})[0];
                        const o = ob.orders && ob.orders[firstKey];
                        if (o && (o.bids || o.asks)) {
                            // same context fetch as above
                            const [optsResp, afResp, cgResp, tkResp] = await Promise.allSettled([
                                fetch('./api/options'),
                                fetch('./api/available_fiats'),
                                fetch('./api/coingecko_prices'),
                                fetch('./api/tickers')
                            ]);
                            let selectedFiat = null; let availableFiats = []; let coingeckoPrices = null; let kdfTickers = null;
                            try{ if(optsResp.status==='fulfilled' && optsResp.value.ok){ const oj = await optsResp.value.json(); selectedFiat = (oj.options||{}).selected_fiat_currency || null } }catch(e){}
                            try{ if(afResp.status==='fulfilled' && afResp.value.ok){ const afj = await afResp.value.json(); availableFiats = afj.available_fiats || []; } }catch(e){}
                            try{ if(cgResp.status==='fulfilled' && cgResp.value.ok){ const cj = await cgResp.value.json(); coingeckoPrices = cj.prices || {}; } }catch(e){}
                            try{ if(tkResp.status==='fulfilled' && tkResp.value.ok){ const tj = await tkResp.value.json(); kdfTickers = (tj && (tj.result||tj)) || null; } }catch(e){}

                            displayOrderbook({ bids: o.bids || [], asks: o.asks || [], spread: ob.spread || '0.0', selectedFiat, availableFiats, coingeckoPrices, kdfTickers, base: base, rel: rel });
                        } else {
                            console.error('Orderbook: unexpected response shape', j);
                            displayError('Unexpected orderbook response');
                        }
                    } else {
                        console.error('Orderbook: unexpected response shape', j);
                        displayError('Unexpected orderbook response');
                    }
                } catch (e) {
                    console.error('Orderbook fetch error:', e);
                    displayError(e && e.message ? e.message : String(e));
                }
                updateLastUpdated();
                
            } catch (error) {
                console.error('Error loading orderbook:', error);
                displayError(error.message);
            }
        }

        function round6(v) {
            const n = Number(v);
            if (!isFinite(n)) return v;
            return n.toFixed(6);
        }

        function displayOrderbook(data) {
            orderbookData = data;

            // Update spread
            document.getElementById('spread').textContent = data.spread;

            // Helpers to extract decimals
            const extractDecimal = (v) => {
                if (v === null || v === undefined) return '';
                if (typeof v === 'string' || typeof v === 'number') return String(v);
                if (v && typeof v === 'object' && v.decimal) return String(v.decimal);
                return '';
            };

            const computeFiatForPrice = (priceStr, coin, ctx) => {
                try{
                    if(!ctx) return 'N/A';
                    const selectedFiat = ctx.selectedFiat;
                    const availableFiats = ctx.availableFiats || [];
                    const coingeckoPrices = ctx.coingeckoPrices || {};
                    const kdfTickers = ctx.kdfTickers || {};
                    // Prefer CoinGecko price for coin (mapped in coingeckoPrices by ticker)
                    if(coingeckoPrices && Object.keys(coingeckoPrices).length){
                        const cp = coingeckoPrices[coin] || coingeckoPrices[coin.toUpperCase()];
                        if(cp && cp.price){
                            const fiatVal = cp.fiat || (ctx.selectedFiat && ctx.selectedFiat.toLowerCase()) || null;
                            // coingeckoPrices price is already in selected fiat when available
                            const p = Number(priceStr);
                            const priceInFiat = Number(cp.price);
                            if(!isNaN(p) && isFinite(priceInFiat)){
                                const v = p * priceInFiat;
                                return isFinite(v) ? v.toFixed(2) : 'N/A';
                            }
                        }
                    }
                    // fallback to KDF tickers USD-based
                    if(!selectedFiat || !kdfTickers) return 'N/A';
                    const kk = (kdfTickers[coin] || kdfTickers[coin && coin.toUpperCase()]);
                    let usdPrice = null;
                    if(kk){ if(typeof kk === 'number') usdPrice = kk; else if(kk.price) usdPrice = Number(kk.price); else if(kk.usd_price) usdPrice = Number(kk.usd_price); }
                    if(usdPrice === null) return 'N/A';
                    const match = availableFiats.find(x => (x.currency && x.currency.toUpperCase() === selectedFiat.toUpperCase()) || (x.entity_id && x.entity_id.toUpperCase().indexOf(selectedFiat.toUpperCase())!==-1));
                    if(!match || !match.state) return 'N/A';
                    const fx = Number(match.state);
                    const p = Number(priceStr);
                    if(!isFinite(fx) || isNaN(p) || !isFinite(usdPrice)) return 'N/A';
                    const v = p * Number(usdPrice) * fx;
                    return isFinite(v) ? v.toFixed(2) : 'N/A';
                }catch(e){return 'N/A';}
            };

            // Update bids table - use same columns as best orders
            const bidsTable = document.getElementById('bids-table');
            bidsTable.innerHTML = '';
            (data.bids || []).forEach(bid => {
                const price = extractDecimal(bid.price) || extractDecimal(bid.price_fraction) || '';
                const volume = extractDecimal(bid.maxvolume) || extractDecimal(bid.max_volume) || extractDecimal(bid.rel_max_volume) || extractDecimal(bid.volume) || '';
                const min_rel = extractDecimal(bid.rel_min_volume) || extractDecimal(bid.min_volume) || '';
                const max_rel = extractDecimal(bid.rel_max_volume) || extractDecimal(bid.maxvolume) || '';
                const min_base = extractDecimal(bid.base_min_volume) || '';
                const max_base = extractDecimal(bid.base_max_volume) || extractDecimal(bid.base_max_volume) || '';
                const priceFiat = computeFiatForPrice(price, bid.coin, { selectedFiat: data.selectedFiat, availableFiats: data.availableFiats, kdfTickers: data.kdfTickers });
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="left">${bid.coin || ''}</td>
                    <td class="price bid">${round6(price) || '--'}</td>
                    <td class="price bid">${round6(priceFiat)}</td>
                    <td class="volume">${round6(min_rel) || '--'}</td>
                    <td class="volume">${round6(max_rel) || '--'}</td>
                    <td class="volume">${round6(min_base) || '--'}</td>
                    <td class="volume">${round6(max_base) || '--'}</td>
                `;
                bidsTable.appendChild(row);
            });

            // Update asks table
            const asksTable = document.getElementById('asks-table');
            asksTable.innerHTML = '';
            (data.asks || []).forEach(ask => {
                const price = extractDecimal(ask.price) || extractDecimal(ask.price_fraction) || '';
                const volume = extractDecimal(ask.maxvolume) || extractDecimal(ask.max_volume) || extractDecimal(ask.rel_max_volume) || extractDecimal(ask.volume) || '';
                const min_rel = extractDecimal(ask.rel_min_volume) || extractDecimal(ask.min_volume) || '';
                const max_rel = extractDecimal(ask.rel_max_volume) || extractDecimal(ask.maxvolume) || '';
                const min_base = extractDecimal(ask.base_min_volume) || '';
                const max_base = extractDecimal(ask.base_max_volume) || extractDecimal(ask.base_max_volume) || '';
                const priceFiat = computeFiatForPrice(price, ask.coin, { selectedFiat: data.selectedFiat, availableFiats: data.availableFiats, kdfTickers: data.kdfTickers });
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="left">${ask.coin || ''}</td>
                    <td class="price ask">${round6(price) || '--'}</td>
                    <td class="price ask">${round6(priceFiat)}</td>
                    <td class="volume">${round6(min_rel) || '--'}</td>
                    <td class="volume">${round6(max_rel) || '--'}</td>
                    <td class="volume">${round6(min_base) || '--'}</td>
                    <td class="volume">${round6(max_base) || '--'}</td>
                `;
                asksTable.appendChild(row);
            });
        }

        function displayError(message) {
            const bidsTable = document.getElementById('bids-table');
            const asksTable = document.getElementById('asks-table');
            
            bidsTable.innerHTML = `<tr><td colspan="3" class="error">Error: ${message}</td></tr>`;
            asksTable.innerHTML = `<tr><td colspan="3" class="error">Error: ${message}</td></tr>`;
            
            document.getElementById('spread').textContent = '--';
        }

        function updateLastUpdated() {
            const now = new Date();
            document.getElementById('last-updated').textContent = 
                `Last updated: ${now.toLocaleTimeString()}`;
        }

        function refreshOrderbook() {
            loadOrderbook();
        }

        // Future function to integrate with real KDF API
        async function fetchRealOrderbook(base, rel) {
            try {
                const response = await fetch(KDF_RPC_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        method: 'orderbook',
                        params: {
                            base: base,
                            rel: rel
                        },
                        userpass: RPC_PASSWORD
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }

                return data.result;
            } catch (error) {
                console.error('KDF API Error:', error);
                throw error;
            }
        }
    </script>
</body>
</html>
